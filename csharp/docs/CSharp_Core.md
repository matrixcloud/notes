# C#的核心基础

## 委托

委托（delegate）在某种程度上提供了间接的方法。c#的委托和现实世界的遗嘱一样，也要在恰当的时间执行一系列操作。
如果代码想要执行操作，而不知道操作细节，一般可以使用委托。

### 委托的构成

- 声明委托类型
- 必须有一个方法包含了要执行的代码
- 必须创建一个委托实例
- 必须调用（invoke）委托实例

```c#
delegate void StringProcessor(string input);
```

以上代码指出，如果要创建一个StringProcessor的一个实例，需要只带一个参数的方法，且这个方法有个void返回类型。
重点在于，``` StringProcessor ``` 其实是一个从System.MulticastDelegate派生的类型，后者又派生自System.Delegate.

找到一个方法，它能做我们想做的事情，同时具有和委托类型相同的签名。基本思路是，要确保在调用（invoke）一个委托实例时，使用的参数完全匹配，而且能以我们希望的方式使用返回值。
以下为 ``` StringProcessor ``` 实例的2个备选方法签名：

``` c#
void PrintString(string x); // 合理
void PrintObject(object x); // 由于string是从object派生的，合理
```

至于用什么形式的表达式来创建委托实例，取决于操作使用实例方法还是静态方法。
假定PrintString是StaticMethods中的一个静态方法，在InstanceMethods中是实例方法。

```c#
StringProcessor proc1, proc2;
proc1 = new StringProcessor(StaticMethods.PrintString);
proc2 = new StringProcessor(new InstanceMethods().PrintString);
```

在实例方法中，实例对象被称为**操作的目标**。

> 必须注意：假如委托实例本身不能被回收，委托实例会阻止它的目标被作为垃圾回收。
> 这可能造成明显的内存泄露（leak）。

对委托实例的调用：

```c#
proc1("Hello world!");
         |
         | 编译成
         ↓
proc1.Invoke("Hello world!");
         |
         | 在执行时调用
         ↓
PrintString("Hello world!");
```

### 委托的合并和删除

在实际情况中：委托实例实际上有一个操作列表与之相关联。这称为**委托实例的调用列表（invocation list）**
System.Delegate类型的静态方法Combine和Remove负责何必和删除实例。

> **委托是不易变的** 创建了委托实例后，有关于它的一切就不能改变。这样一来，就可以安全地传递委托实例的引用，并把它们与其他委托实例合并，同时不必担心一致性、线程安全性或者是否有其他人试图更改它。

### 委托总结

- 委托封装了包含特殊返回类型和一组参数的行为，类似包含单一方法的接口。
- 委托类型声明中所描述的类型签名决定了哪个方法可以用于创建委托实例，同时决定了调用的签名。
- 为了创建委托实例，需要一个方法以及调用方法的目标。
- 委托实例是不易变的。
- 每个委托实例都包含一个调用列表。
- 委托实例可以合并在一起，也可以从一个委托实例中删除另一个。
- 事件不是委托实例。

## 类型系统的特征

### 静态类型和动态类型

- 静态类型：每个变量都有一个特定的类型，而且该类型在编译时是已知的。

> **静态**这个词用来描述表达式的编译时类型，因为它们使用不变的（unchanging）数据来分析哪些操作可用。
> 假设某个变量声明为Stream类型，那么不管变量的值为MemoryStream还是FileStream，甚至不是流类型，它的类型都不会发生改变。
> 然而静态类型系统中也可以有一些动态行为，如虚方法调用所执行的实际实现依赖于所调用的对象。

- 动态类型：动态类型的实质是变量中含有值，但是那些值并不限于特定的类型。相反，执行环境试图采取一种合适的方式来理解引用值的给定表达式。

### 显式类型和隐私类型



## 值类型和引用类型

## 