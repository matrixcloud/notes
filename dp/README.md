## 原则

- 封装变化
- 少用继承，多用组合
- 针对接口编程，而不是针对实现
- 开闭原则：对扩展开放，对修改关闭
- 依赖倒置原则

## 策略模式 (Strategy Pattern)

定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户

## 观察者模式 (Oberserver Pattern)

在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新

- `setChanged()`
- `pull` 模式
- `push` 模式

```java
// 主要为了提供更新频率的控制
setChanged() {
    changed = true
}

notifyAll() {
    if (changed) {
        for every observer on the list {
            call update
        }
        changed = false
    }
}
```

## 装饰者模式 (Decorator Pattern)

动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

- 装饰者与被装饰者具有相同的超类型
- 可以用一个或多个装饰者包装一个对象
- 装饰者可以在所委托被装饰者的行为之前与之后，加上自己的行为，以达到特定的目的
- 对象可以在任何时候被装饰

## 工厂模式 (Factory Pattern)

工厂模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

